package gui.tools;

import gui.analyzer.util.Util;
import gui.model.application.scenes.Scene;
import gui.model.domain.ComponentInfoType;
import gui.model.domain.DomainModel;
import gui.model.domain.Term;
import gui.model.domain.relation.RelationType;
import gui.tools.exception.ExtractionException;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.Iterator;
import java.util.List;

import javax.swing.JLabel;

public abstract class AbstractDealExtractor {
	protected DomainModel domainModel;
	@SuppressWarnings("rawtypes")
	protected Scene scene;
	protected Term rootTerm;
	protected String sceneName;
	
	/**
	 * Create a subtree in the domain model. The subtree is created from
	 * information extracted from the component tree - recusively. Each
	 * recursive cycle has four steps: - traversing the superclasses to find the
	 * DomainIdentifiable handler. - if no handler is found in the first step,
	 * then extract the basic information available in the current component. -
	 * try to extract any information from the custom types of components. The
	 * tryCustom(..) method is available to add new extraction rules. - the
	 * fourth step is an attempt to use the extractSubtree() method recursively
	 * for each subcomponent of the current component - but only if the current
	 * component is a Composite (i.e. a container).
	 * 
	 * @param component
	 *            The current component which the new term subtree should be
	 *            extracted from.
	 * @param parentTerm
	 *            a future parent of the newly created subtree.
	 */
	protected abstract <E> void extractSubtree(E component, Term parentTerm);
	
	/**
	 * Extracts a domain model from the given scene.
	 * @param scene the scene the domain model should be extracted from
	 * @return the extracted domain model
	 * @throws ExtractionException if the scene is null or if the extracted domain model is null
	 */
	@SuppressWarnings("rawtypes")
	public DomainModel eXTRACT(Scene scene) throws ExtractionException {
		if (scene != null) {
			this.scene = scene;
			this.sceneName = scene.getName();
			this.domainModel = scene.getDomainModel();
		} else
			throw new ExtractionException("Scene must not be null");

		if (domainModel != null) {
			this.rootTerm = domainModel.getRoot();
		} else
			throw new ExtractionException("DomainModel must not be null");

		eXTRACT();

		return domainModel;
	}

	
	protected void eXTRACT() {
		// extract subtree from the root scene
		extractSubtree(scene.getSceneContainer(), rootTerm);

		// additional derivation of relations from parents
		findParentRelationsInModel();

		// removes all labelfors which describe other components and moves all
		// content from the label to the component.
		transferLabelFors(rootTerm);

		// find separators
		findSeparatorsInModel();

		// set the model root name and type and references to the scene
		domainModel.getRoot().setName(sceneName);
		domainModel.getRoot().setRelation(RelationType.MODEL);
		domainModel.getRoot().setComponent(scene);
		domainModel.setScene(scene);
	}


	//<editor-fold defaultstate="collapsed" desc="findParentRelationsInModel">
	/**
	 * Additional sub-step of the extraction phase - extraction of additional
	 * relations from parent components. Finds parent relations in the whole
	 * domain model. A parent relation is a relation, which is generated by a
	 * parent term for its children. For example, because of a JTabbedPane, the
	 * tabs are mutually exclusive. This method works recursively for the whole
	 * subtree of thisTree. A HashMap is created for each type of parent
	 * relation. This is for a case, where the parent generates a relation only
	 * for a subset of its children - in such a case a new subterm is generated
	 * for the group with the new relation and the other terms will remain in
	 * thisTerm children list.
	 * 
	 * @param model
	 *            The domain to search the parent relations in.
	 */
	private void findParentRelationsInModel() {
		// if there is nothing in the model, do nothing
		if (domainModel.getRoot() == null
				|| domainModel.getRoot().getChildrenCount() == 0)
			return;

		// recursively find parent relations in each subtree, starting with root
		findParentRelations(domainModel.getRoot());
	}

	/**
	 * This method is called recursively and it is started by the
	 * findParentRelationsInModel(..) method. Finds parent relations in a
	 * subtree of the domain model. A parent relations is a relation, which is
	 * generated by a parent term for its children. For example, because of a
	 * JTabbedPane, the tabs are mutually exclusive. This method works
	 * recursively for the whole subtree of thisTree. A HashMap is created for
	 * each type of parent relation. This is for a case, where the parent
	 * generates a relation only for a subset of its children - in such a case a
	 * new subterm is generated for the group with the new relation and the
	 * other terms will remain in thisTerm children list.
	 * 
	 * @param thisTerm
	 *            The term, which generates the relations for its children.
	 */
	private void findParentRelations(Term thisTerm) {
		HashMap<RelationType, List<Term>> parentRelations = collectParentRelations(thisTerm);

		detectDirectSiblings(parentRelations);

		shiftTermsWithParentRelations(parentRelations, thisTerm);

		// do this recursively
		for (int i = 0; i < thisTerm.getChildrenCount(); i++) {
			findParentRelations(thisTerm.getChildAt(i));
		}
	}

	private void shiftTermsWithParentRelations(
			HashMap<RelationType, List<Term>> parentRelations, Term thisTerm) {
		// for each relation type in the key set of parentRelations
		// create a new subterm of thisTerm and add all its children with this
		// type of parentRelation into this subterm.
		// Remove the children from the original parent.
		for (RelationType pr : parentRelations.keySet()) {
			// create a new term
			Term newTerm = new Term(thisTerm.getDomainModel());
			// set its relation to parentRelation
			newTerm.setRelation(pr);

			// for each term in the list under the parentRelation key
			// shift every term from thisTerm to the newTerm
			for (Term t : parentRelations.get(pr)) {
				thisTerm.removeChild(t);
				newTerm.addChild(t);
				t.setParentRelation(null);

				JLabel labelFor = t.getLabelForComponent();
				if (labelFor != null && !Util.isEmpty(labelFor.getText())) {
					newTerm.setLabelForComponent(labelFor);
					newTerm.setName(labelFor.getText());
				}
			}

			thisTerm.addChild(newTerm);
		}
	}

	private HashMap<RelationType, List<Term>> collectParentRelations(
			Term thisTerm) {
		HashMap<RelationType, List<Term>> parentRelations = new HashMap<RelationType, List<Term>>();

		// put all children of thisTerm into a list under the parentRelation key
		// in the parentRelations hash map.
		for (int i = 0; i < thisTerm.getChildrenCount(); i++) {
			Term t = thisTerm.getChildAt(i);

			// get parentRelation from term - this is stored during the Term
			// creation
			// @see gui.analyzer.handlers.DomainIdentifiable.createTerm(..)
			RelationType pr = t.getParentRelation();
			if (pr != null) {
				// for each relation type there is a list of components, to
				// which this relation should be applied - add the child into
				// this list.
				if (!parentRelations.keySet().contains(pr)) {
					parentRelations.put(pr, new ArrayList<Term>());
				}
				parentRelations.get(pr).add(t);
			}
		}

		return parentRelations;
	}

	private void detectDirectSiblings(
			HashMap<RelationType, List<Term>> parentRelations) {
		Iterator<RelationType> prIterator = parentRelations.keySet().iterator();
		while (prIterator.hasNext()) {
			RelationType pr = prIterator.next();

			List<Term> list = parentRelations.get(pr);
			list = removeTermsWhichAreNotDirectSiblings(list);

			if (list.isEmpty()) {
				prIterator.remove();
			}
		}
	}

	private List<Term> removeTermsWhichAreNotDirectSiblings(List<Term> terms) {
		List<Term> termsToRemove = new ArrayList<Term>();

		Iterator<Term> i1 = terms.iterator();
		while (i1.hasNext()) {
			boolean isSibling = false;
			Term t = i1.next();

			Iterator<Term> i2 = terms.iterator();
			while (i2.hasNext()) {
				Term sibling = i2.next();
				if (!t.equals(sibling) && t.isDirectSiblingTo(sibling)) {
					isSibling = true;
				}
			}

			if (!isSibling)
				termsToRemove.add(t);
		}

		for (Term t : termsToRemove) {
			t.setParentRelation(null);
			terms.remove(t);
		}

		return terms;
	}
	//</editor-fold>
	

	/**
	 * Removes labels which describe other components and transfers all the
	 * information and children into these components.
	 * 
	 * @param thisTerm
	 *            The term which should be checked for labelFors.
	 * @return if anything was removed, returns true, false otherwise
	 */
	private boolean transferLabelFors(Term thisTerm) {
		boolean wasRemoved = false;
		Iterator<Term> i = thisTerm.iterator();
		while (i.hasNext()) {
			// component term - this will be the new term with a description
			// from the JLabel
			Term componentTerm = i.next();

			if (componentTerm.getLabelForComponent() != null) {
				// label term - this will be deleted and all information will be
				// transfered to ct
				Term labelTerm = domainModel.getTermForComponent(componentTerm
						.getLabelForComponent());

				if (labelTerm != null) {
					// move all children of label to the component
					if (labelTerm.hasChildren())
						componentTerm.addAll(labelTerm.getChildren());

					// transfer name and description from label to component
					if (!componentTerm.hasName())
						componentTerm.setName(labelTerm.getName());
					else if (!componentTerm.hasDescription())
						componentTerm.setDescription(componentTerm.getLabelForComponent().getText());
					if (!componentTerm.hasIcon())
						componentTerm.setIcon(labelTerm.getIcon());
					
					// empty the label term and prepare it to be removed in the next deal stage == remove name, description and icon
					labelTerm.removeDomainInformation();
					wasRemoved = true;
				}
			}
		}
		
		//do this for all children of this term
		i = thisTerm.iterator();
		while(i.hasNext()) {
			Term next = i.next();
			wasRemoved |= transferLabelFors(next);
		}

		//IT WORKS!!!!!!!!!!!! :DDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDD
		
		return wasRemoved;
	}

	
	private void findSeparatorsInModel() {
		if (domainModel.getRoot() == null
				|| domainModel.getRoot().getChildrenCount() == 0) {
			return;
		}
		findSeparators(domainModel.getRoot());
	}

	private void findSeparators(Term thisTerm) {
		List<List<Term>> childrenToSeparate = new ArrayList<List<Term>>();
		childrenToSeparate.add(new ArrayList<Term>());

		Iterator<Term> i = thisTerm.iterator();

		// find separators - if there are any, then the childrenToSeparate list
		// will contain more than one list of terms.
		// the separators will be removed because they are not representing
		// terminology
		while (i.hasNext()) {
			Term child = i.next();
			if (child.getComponentInfoType() == ComponentInfoType.SEPARATORS
					&& childrenToSeparate.size() > 0) {
				childrenToSeparate.add(new ArrayList<Term>());
				i.remove(); // remove the separator
			} else {
				// add term into the last term list in the childrenToSeparate
				// list
				childrenToSeparate.get(childrenToSeparate.size() - 1)
						.add(child);
			}
		}

		// transfer the children into separated groups (if there are any)
		if (childrenToSeparate.size() > 1) {
			for (List<Term> subList : childrenToSeparate) {
				thisTerm.removeAll(subList);
				Term newSubItem = new Term(domainModel);

				newSubItem.addAll(subList);

				thisTerm.addChild(newSubItem);
			}
		}

		// do the same for all children
		i = thisTerm.iterator();
		while (i.hasNext()) {
			Term child = i.next();
			findSeparators(child);
		}
	}
}
